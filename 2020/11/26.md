- [单页应用的数据流方案探索](https://github.com/xufei/blog/issues/47)
    - 解读 Redux 的命令式驱动理念 —— MDV（ Model Driven View ）：一般的映射 `V = f(M)`，变更时的映射 `V + ΔV = f(M + ΔM)` 或 `ΔM = perform(action)`，整体的映射 `state := actions.reduce(reducer, initState)`
    - Pipe 这个东西是数据和行为的共同复用
    - Pipe 是懒的，这点和 Observable 的 Cold 概念一致
    - Pipe 产生的数据流可以将很多东西提高一个抽象层次
    - Redux 的思想其实就是将一些切面的上下游分开，比如一个行为切面，上游数据来自于多个源头，下游会被多个地方订阅，上下游是互不关心的，都只关心这一个行为
    - Redux 的另一层意义：将状态管理剥离出组件树（ 倒置的 ），中心化到一些中继器中
    - 状态应该逐级传递还是中继管理 = 组件是充血还是贫血 = 组件是否是纯的 —— 展示而不含逻辑和状态，即最开始说的 MDV 纯映射
    - 纯组件利于 HMR，是非常独立的
    - [You Might Not Need Redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) 表达了 Local state is fine. 退一步讲就是 You can apply ideas from Redux without using Redux。和之前了解到的「 If not sure if you should use Redux, then don't. 」想法一致
    - [Plug and Play All Your Observable Streams With CycleJS](https://medium.com/@fkrautwald/plug-and-play-all-your-observable-streams-with-cycle-js-e543fc287872) 介绍了 MVI（ Model View Intent ）。理解为 `App/Component := View(Model(Intent({ DOM, Http, WebSocket })))`：Intent 负责从事件源中抽取有效数据，Model 负责转化为视图能接受的结构，View 负责输出视图。比较明显的差异是，View 不负责订阅 DOM 事件，而是交给 Intent 去收集（ 合理性附议 ）；Model 的上游只有 Intent，且 Model 的状态不分组件内外。再结合组件树，每个 Component 都有自己的 MVI，整个树组成了 App
    - Redux 让事情复杂化的原因是必须基于显示 key 的 Action 声明，但如果每个 Component 都有 MVI，很多时候 key 和 type 是用不到的（ 只关心 payload ），我理解这就可以在内置的 Model 中用流来简化（ merge 多个行为然后 fold 掉没用的 ）
    - 基于上点，作者认为 Redux 配合 React 的完整视图是状态变更的 `单独发现 - 合并丢弃 - 单独获取` 的过程，是浪费的。利用 Pipe 的懒特性，组件本身的 Model 可以「 接管 」更多的事情，而不是都要放到 Store 去做
    - 大型项目中，Store 的结构应是稳定的，需要尽早确定，消除视图组件在理解数据上的歧义，而多个视图以不同的业务含义去看待状态树上的同一个分支是各自的事情，不需要 Store 关心。因此得到一个结论，Store 应该是简单的，所以结构可能是扁平的
    - 最终终于延展到这个话题 —— 前端的数据层建模，就是自己完成一套数据库，并实现良好的读写分离 —— 写是靠类似 Action 的行为，读是靠 Pipe 组合订阅。全局唯一的中心化 Store 就是唯一的数据库，组件树上的每个组件有自己的读写闭环，自己的 Model 控制了是否要读写数据库
    - 说到这里，和我之前写的 Angular 分层架构非常吻合 —— 必要的话，每个 Component 有自己的 ComponentClass（ View ）、LogicService（ 纯逻辑 ）和 StateService（ 状态管理 ），组件内部是可以自洽的。而每个模块中，有高阶的 LogicService 和 StateService，然后有全局单例的 LogicService 和 StateService。不同层级之间借助 RxJS 的抽象和异步同步统一能力进行通讯，借助 Pipe 的拼接、组合、缓存、回放能力进行数据控制
