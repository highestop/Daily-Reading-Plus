# [单页应用的数据流方案探索](https://github.com/xufei/blog/issues/47)

- 解读 Redux 的命令式驱动理念 —— MDV（ Model Driven View ）：一般的映射 `V = f(M)`，变更时的映射 `V + ΔV = f(M + ΔM)` 或 `ΔM = perform(action)`，整体的映射 `state := actions.reduce(reducer, initState)`
- Pipe 这个东西是数据和行为的共同复用
- Pipe 是懒的，这点和 Observable 的 Cold 概念一致
- Pipe 产生的数据流可以将很多东西提高一个抽象层次
- Redux 的思想其实就是将一些切面的上下游分开，比如一个行为切面，上游数据来自于多个源头，下游会被多个地方订阅，上下游是互不关心的，都只关心这一个行为
- Redux 的另一层意义：将状态管理剥离出组件树（ 倒置的 ），中心化到一些中继器中
- 状态应该逐级传递还是中继管理 = 组件是充血还是贫血 = 组件是否是纯的 —— 展示而不含逻辑和状态，即最开始说的 MDV 纯映射
- 纯组件利于 HMR，是非常独立的
- [You Might Not Need Redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) 表达了 Local state is fine. 退一步讲就是 You can apply ideas from Redux without using Redux。和之前了解到的「 If not sure if you should use Redux, then don't. 」想法一致
- [Plug and Play All Your Observable Streams With CycleJS](https://medium.com/@fkrautwald/plug-and-play-all-your-observable-streams-with-cycle-js-e543fc287872) 介绍了 MVI（ Model View Intent ）。理解为 `App/Component := View(Model(Intent({ DOM, Http, WebSocket })))`：Intent 负责从事件源中抽取有效数据，Model 负责转化为视图能接受的结构，View 负责输出视图。比较明显的差异是，View 不负责订阅 DOM 事件，而是交给 Intent 去收集（ 合理性附议 ）；Model 的上游只有 Intent，且 Model 的状态不分组件内外。再结合组件树，每个 Component 都有自己的 MVI，整个树组成了 App
- Redux 让事情复杂化的原因是必须基于显示 key 的 Action 声明，但如果每个 Component 都有 MVI，很多时候 key 和 type 是用不到的（ 只关心 payload ），我理解这就可以在内置的 Model 中用流来简化（ merge 多个行为然后 fold 掉没用的 ）
- 基于上点，作者认为 Redux 配合 React 的完整视图是状态变更的 `单独发现 - 合并丢弃 - 单独获取` 的过程，是浪费的。利用 Pipe 的懒特性，组件本身的 Model 可以「 接管 」更多的事情，而不是都要放到 Store 去做
- 大型项目中，Store 的结构应是稳定的，需要尽早确定，消除视图组件在理解数据上的歧义，而多个视图以不同的业务含义去看待状态树上的同一个分支是各自的事情，不需要 Store 关心。因此得到一个结论，Store 应该是简单的，所以结构可能是扁平的
- 最终终于延展到这个话题 —— 前端的数据层建模，就是自己完成一套数据库，并实现良好的读写分离 —— 写是靠类似 Action 的行为，读是靠 Pipe 组合订阅。全局唯一的中心化 Store 就是唯一的数据库，组件树上的每个组件有自己的读写闭环，自己的 Model 控制了是否要读写数据库
- 说到这里，和我之前写的 Angular 分层架构非常吻合 —— 必要的话，每个 Component 有自己的 ComponentClass（ View ）、LogicService（ 纯逻辑 ）和 StateService（ 状态管理 ），组件内部是可以自洽的。而每个模块中，有高阶的 LogicService 和 StateService，然后有全局单例的 LogicService 和 StateService。不同层级之间借助 RxJS 的抽象和异步同步统一能力进行通讯，借助 Pipe 的拼接、组合、缓存、回放能力进行数据控制

# [老码农的技术理想](https://github.com/xufei/blog/issues/16)

- 什么叫业务？其实就是行业常识，生活经验
- 懂业务的往往比懂技术的更多，但现在更多是年轻的技术人员去学业务，从而跟上生产需求
- 如何让业务人员更好地参与软件研发过程。根本解决方法是 DSL（ Domain Specific Language ），核心解决方案是二次开发平台（ No-Code 平台？ ）
- 高效的做法是：技术人员和业务人员一起定义 DSL，技术人员负责 DSL 的底层平台实现，业务人员负责使用它来构建业务模型和业务流程，甚至业务界面
- 整个软件行业的生产力偏低，软件还很贵的原因是人力贵，而人力上有很大的效率损失
- 软件质量不高是因为流程不完善，流程不完善是因为需求多变，需求多变是因为人们潜意识里认为变更成本低，但其实软件工程就和建筑一样
- 作者强调了用「 兜底 」的方法比如测试来尝试提高质量是低效的，更好的做法是从一开始考虑建模去做隔离，使得一定会出现的变化成本降低
- 架构是立体的，因为业务场景不同，所以需要架构管控
- 「 当技术不再成为高高在上、遥不可及的东西，留给我们技术人员的会是什么？我不知道，也许很幸福吧，就像一个职业军人遇到了永久的和平 」
