# [How do you write simple explanations without sounding condescending?](https://jvns.ca/blog/2020/11/15/simple-explanations-without-sounding-condescending/)

- 多用术语（ jargon ）描述，一方面根据之前读的 vocabulary knowledge 这会显得你很在行，另外还能让读者有能够继续查阅相关资料的能力，从而更好入坑
- 准确描述，不要尝试去解释你不确定的信息或至少应该清晰地告诉读者你不确定，否则很容易误导别人，越是简单的事情影响往往越大
- 运用 fun elements 要已 accessible 为前提，它只是个 signal，假如大家的基础一致，这些元素确实会让你的表达更 funny，但如果没给出足够清楚的解释的，读者基本 get 不到，就会有误导
- 使用 relevant story，解决问题的第一步是先表达清楚问题，而且要是实际相关的
  - 就我个人的感受，有时候我们在尝试理解作者想要表达的内容前，会先将自己带入作者的 story 中去在场景中思考。而正是因为会带着自己的思考带入，最终的理解准确度或阅读效率非常依赖这个 story 的准确性及其细节。我觉得，讲故事大家都会，但很多人并没有足够的意识要对讲的故事负责，所以相关性和准确性很重要
- 写作也是一种沟通，沟通通常要基于换位思考的基础上，因此想让读者搞懂你写的东西，可以假设自己是读者，尝试能不能明白
  - 很多时候让组里的同学去和我讲明白一件事或写一份文档，假如有一瞬间觉得他表达的不对，我会建议他假设我是一个新手，再想想如何去表达，我会以一个新手的角度去提问或评论，看他是否能讲清楚。我感觉这种做法能很有效地提醒大家补充一些他们觉得无关紧要但却对对方理解造成困扰的细节


# [Micro Frontends Pattern Comparison](https://blog.bitsrc.io/microfrontend-pattern-comparison-c50a9d2e4172)

- 介绍了 4 种常见的微前端架构范式
  - 编译时集成：多仓库独立开发，汇总单点部署
    - 好处是可以做统一处理，如迁移和优化
    - 但我理解其实没有解决开发效率问题，因为总要 rebuild
    - 理论上编译时可以做很多 AoT 的事情，所以应该可以做按需 rebuild，比如某些 cache
    - 个人觉得用户体验不会有问题
  - SSR 集成：多仓库配合反向代理实现
    - 多 SSR 的调试开发成本可能是难以接受的，个人没体验过但想着就觉得不爱了
    - 作者提到了 content-heavy sites，可能这个思路就是针对于某些场景可尝试
  - 运行时 iframe 嵌套：利用 iframe 内嵌一个窗口，访问其它独立的域名展示动态内容
    - 首先运行时和编译时的最大区别就在于，集成的过程基于用户行为，可以理解为被动的
    - 关键是 isolation，成也是它败也是它。可以做到类似沙箱的隔离效果，而且可以灵活搭配 SSR 等技术。但页面适应能力几乎为无，体验可能会比较差
    - 正是因为这点很明确，所以适用场景也比较明确。比如一个 entry 只是个 frame，其下的各个 content 完全无关且不需要做任何一致性或通讯保证，那可以 iframe 走起，简单高效
  - 运行时解析 js：即一个 app shell 去 bootstrap（ 作者用的词是 load & evaluate ）多个 content，可以理解为一种 plugin mechanism
    - 作者认为可能是个最兼顾开发体验的方式。vscode 就是这么做的，所以在此验证之下肯定有很多 loyal followers
    - 个人认为很多框架有能力提供这种支持，要看具体情况，因为就像作者开头第一句所说，the desire to modularize the frontend has steadily increased
- 结合个人理解谈谈，主要围绕 Angular 吧
  - 我们的经历是直接从 1 跳到了 4
    - 先说说「 编译时集成 」，我们尝试了 monorepo 的方式搞定多个 package，如去对约定的 package.version 做 diff-cache 从而触发 CI/CD，还是完整的一次部署，但是编译会分开多次
    - 为什么直接到「 运行时解析 」，我个人的理由是想充分发挥框架优势，既然有了选型就基于选型去搞上层建筑生态，把很多复杂偏基础的工作交给框架处理
  - Angular 的 NgModule 已经提供了强大的根基，Lazy-Load 很像了，基于 DI 也能搞定 Shell 与各个 Content 之间的交互
  - 问题在于两点：Shared 元素的组织和 Angular-Webpack 的兼容。我们暂时选择了 Shared Library 去做 UI/US/Styling 的统一，用 Webpack Plugin 去 customize 了 Angular 的编译。但 Shared Library 不易过多，我理解就像微服务划分不能太多太细一样，否则开发链路太长
  - 另外 DI 虽然解决了运行时的协调，但没有解决多项目开发问题。对此我的思路是，要么 monorepo 配合足够强大的 CI 实现，要么 Shell 需要给出 SDK，约束各个 Content 的基本环境需要以我 Shell 对齐，毕竟从名字上也能看出运行时的所有环境是由 Shell 定的，包括 Router
  - 我们现在的挑战还有很多。例如 hack Webpack 需要一个类似 zk 的注册中心，用于在 Shell 和各个 Content 之间「 发现 」、「 管理 」和「 通知 」，这个最好要集成 CI/CD，还需要一套 Versioning 方案。再例如，是否要打破 Shell 管理全局环境的前提，因为 Content 可能由多团队管理，一致的依赖可能是不好控制的。还有例如，是否要越过 Angular 基于 RouterModule 的模块加载机制，实现页面上动态载入局部插件的功能，之前自己写了一版 NgPlugin 能一定程度解决这个问题，思想上类似 [Single SPA 的 Parcel](https://single-spa.js.org/docs/parcels-overview)
- 提到了 Single SPA，肯定有人要说 [Qiankun](https://github.com/umijs/qiankun)，或者考虑框架无关的实现。我认为框架无关带来的复杂度会很高，所以是否有价值有待商榷或视情况而定。如果公司有核心选型，我建议还是先围绕它来打造生态，而不需要做多度实现。当然像 Qiankun 这样的方案本身很有意思，不妨碍去了解和研究

# [美团技术团队书单（ 通用能力篇 ）](https://mp.weixin.qq.com/s/5nUqazLLV67H824Jg6kd_A)

排序是个人了解程度从高到低的，完全不知道没读的书就只记了书名

- 《 系统之美 》印象里是《 系统架构 》的入门版本，读过一些
- 《 格鲁夫给经理人的第一课 》经典的技术管理者必读书籍
- 《 原则 》将公司及个人管理的
- 《 潜力量 GROW 》表达了「 表现 = 能力 - 干扰 」，有一些管理性建议，也有个人成长建议，如锻炼专注来抗干扰
- 《 当下的力量 》
- 《 关键时刻 MOT 》
- 《 远见 》
- 《 事实 》
- 《 刷新 》

# [被嫌弃的 35 岁程序员](https://mp.weixin.qq.com/s/ri9eik51MLh8ksesktJYqg)

- 刚转型管理时「 改不了程序员那套习惯 —— 很多事愿意亲力亲为，参与细节，对别人不放心，我自己做最放心。一开始感觉在向务虚的方向走，感觉写的代码少了就和技术脱钩了，时常感到焦虑 」，非常感同身受了。想想我自己大概有两个 Q 左右的时间才调整好自己的节奏，后面还要慢慢培养起自己的管理技能。管人确实和管代码非常不一样，我觉得本质是因为大家都有各自的思想
- 大厂倾向于内部孵化技术管理者，这里有「 忠诚度 」的因素在里面
- 作为管理者并不是不接触代码，相反我觉得对于代码或说一线技术的东西，选择更加自由、更容易沉浸，因此当你想参与时没有掺杂任何功利和紧迫的东西，会让人特别放松
- 从另一个角度讲，用代码实现功能是「 术 」，技术管理工作更像是「 道 」，是对「 观察世界和思考世界的方法 」的吸收和内化，最终表现为把控和决策，从而指导和产生「 术 」

# [你会用到的 15 个前端小知识](https://mp.weixin.qq.com/s/IMQhGAS_TaCDDITgl4Ekew)

- `text-overflow:ellipsis` 的 CSS 文本换行，适用于单行省略和多行
- `::-webkit-scrollbar` 控制滚动条
- 隐藏元素的 `display:none`、`opacity:0` 和 `visibility:hidden` 的区别
- `contenteditable` 的可编辑性
- `Proxy` 区别于 `Object.definedProperty` 的是它还可以监听方法，所以确实更像「 劫持 」

# [设计上的基本常识](https://dubbo.apache.org/zh-cn/docs/dev/principals/general-knowledge.html)

- 个人扩张到团队时，代码规范是必要的，但不用很复杂，从个人习惯出发就好，毕竟之前的代码都是自己写的，且希望前后一致
- 规范的作用有两个：易读、防止低级错误。如：
    - 安全性：判空和越界
    - 尽早失败：越往下游越分散，处理越麻烦
- API 与 SPI 分离，即领域切面分离，调用者和开发者可见的接口最好不共用
- 领域分层，这点很多文章都讲到
    - 如可以分为：
        - 核心域、实体域
        - 服务域、行为域
        - 会话域、内容域
    - 不去控制域之外对象的生命周期
- 服务端的接口尽可能正交，尽责单一且可灵活组合
- 重要的行为过程要有监控和适当的拦截
- 区分命令和查询
    - 命令是返回 void 的，有副作用，即会改变状态或数据
    - 查询有返回值，但没有副作用且是多次幂等的（ 调用多次结果相同 ）
