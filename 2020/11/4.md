# [JavaScript ES12 新特性抢先体验](https://mp.weixin.qq.com/s/T2IkxRp_PXkhk8T_ciLvjw)

重点是逻辑运算符和赋值表达式

# [Building GitHub: Introduction](https://github.blog/2020-10-29-building-github-introduction/)

- Four Key Metrics 四个衡量工程性能的指标
    - Deploy Frequency 部署频率
    - Lead Time for Changes 交付时长
    - Time to Restore Service 恢复时长
    - Change Fail Rate 生产降级的可能性？
- 不同团队会经常性进入别人的领域探索一些可能很陌生问题，但在这个过程中大家都会变得更有热情，因为它提供了发现解决问题的另一个思路的可能性，而且大家明显喜欢保持这种 Cross-Team & Cross-Discipline 的状态
    - 最开始团队人少时为了保证 Backup 采用的是「 被动轮询 」的方式，没有人固定对某模块负责
    - 等到人手足够之后就倾向于稳定和确定的分工保证高效，并且利于区分模块边界
    - 再复杂，是不是会因为流程问题导致「 等不及 」别人去解决问题，就变成「 主动且临时 」调整下工作目标
- 延展阅读 State of DevOps 2019 https://services.google.com/fh/files/misc/state-of-devops-2019.pdf 太长还没读

# [Making GitHub CI workflow 3x faster](https://github.blog/2020-10-29-making-github-ci-workflow-3x-faster/)

- Github 最开始 CI 也要 45 分钟但最后降低到了 15，解决这个问题大概做了几方面事情：
    - 都有哪些 CI 要跑？静态检查、单元测试、集成测试、编译打包 4 种
    - 将耗时长的 test suites 抽离出来，长周期执行，不阻塞日常开发部署
    - Deferred Compliance 延迟到 PR 之后做一些合规检测，如出错你必须在一个 DDL 之前解决否则所有部署会停止直到问题被解决，你就被问责了。Clock is ticking!
        - 感觉就是将错误分级，允许一些容错（ 存在一段合理的时间 ）？
- 总结三句话：
    - 工具很重要，能持续起到工程「 护航 」的作用
    - 明确的指标易于在复杂过程中找到瓶颈、优先解决它们
    - 要多复盘历史并换角度（ 把自己作为「 客户 」）看问题

# [再读《 重构 》](https://mp.weixin.qq.com/s/bSaOGdmcA9ctwPwDqvTjjQ)

- 重构的原则：
    - 不应改变用户可观测的行为
    - 应做到能随时回退到原始状态，重新来过
    - 代码在大部分时间处于可用状态（ 持续在生产得到验证 ）
- 重构的目的：
    - 应该是提效，是一种经济角度的考量，而非道德要求
    - 应该尽可能一致，只有具体的执行方式是可讨论的
- 重构的意识：
    - 大多数都不是特意为止，而是见机行事，意识应该存在于所有人心中
- 重构的要求：自测试代码、持续集成、继续重构
    - 这三者组成了 TDD
    - 缺少 T 是很致命的，因为无法验证可用，使得重构畏手畏脚
- 重构的执行：
    - 小步重构，安全进行
        - 尽可能 pair 来执行重构，多与原 committer 沟通
        - 团队内执行重构时 review 频率越高、粒度越小越好，不需要多重分支进行 MR/PR review
            - 基于 Github 的 PR review 机制是因为分布式团队造成的，这其实不够敏捷，也因此需要分支权限控制，因为大家水平参差不齐
        - 非常容易造成冲突，因此推荐 TBD 单分支策略
            - 还是基于原则三，保证尽可能少的分支在尽可能少的时间处于游离状态
    - 营地法则：离开一个摊子时至少让这个地方变得更干净
        - 结合小步重构，积少成多，工程一定越来越健康，反之久而久之就会变腐化
        - 某种程度上讲这与「 简单搞 」是矛盾的
    - 捡垃圾式重构，针对性高地重构，立即进行或标记下来
    - 测试不一定多就好，重点来自于人对代码的主观信心
        - 太少觉得没底，太多容易改不动
        - 将有限的测试精力和资源用在最容易出错和最没有信心的地方
        - 业务测试尽量基于工具而非基于框架
            - Angular 的 TestBed 在测试基础组件功能时是必须的，但在测试业务组件时会执行大量框架代码，导致效率低

# [埃森哲的工作法《 掌控工作 》](https://mp.weixin.qq.com/s/9LBwfuZLtKDaD7cfXBtJkQ)

- 关键词：工作框架
    - 掌控自己的节奏
    - 如果你是管理岗，还要掌控大家的节奏
- 界定问题
    - 问题是什么？如果是个陌生领域的问题，先要搞清楚这个「 敌人 」是谁
    - 介绍了一种 What-Else 模式，即「 这是什么 」和「 除了这个还有什么 」，知道一个领域内的横向术语之后才有利于理解问题本身
- 拆解问题
    - 即大事化小，要知道先后顺序
    - 可以参考《 金字塔原理 》中的 MECE 原则，即不重不漏
    - 用「 假设驱动 」和 28 原则来在大量的 TODO 中定位优先问题 —— 用 20% 的成本能收到 80% 的提高
- 执行解决：用 Card 来表示一个个拆解后的子问题
    - 第一步：确定工作目标，估算工作量
        - Card 有哪些，分别占多大空间
    - 第二步：对工作进行优先级排序
        - 将 Card 进行排序
    - 第三步：确定时间规划，把工作指派给各项目负责人
        - 将 Card 标注给资源，保证资源的合理分配，不重（ 冲突 ）不漏（ 高效 ）
        - 这里强调了无论是叶子节点的实现还是中间节点的模块负责人，都必须有 Owner 制度
    - 第四步：提前对风险点提出预案
        - 是否有另一条路成为 Backup，如最佳方案不可执行了，是否有能达到目的的第二有效方案
    - 进行中时：
        - 定期进行同步
        - 如果拆解问题合理，不必要在意具体的实现细节
        - 同步的另一个好处是每个人形成工作闭环，大白话讲就是分工明确
        - 要经常性扣题，保证没有跑题
- 总结复盘
    - 第一步：回顾目标
    - 第二步：评估结果
    - 第三步：原因分析
    - 第四步：优化改善
    - 能形成方法论而演进团队执行的一些潜在标准则更好

# [聊聊 JavaScript 的并发、异步和事件循环](https://zhuanlan.zhihu.com/p/266687842)

- JS 的运行有两层 —— Engine 和 Runtime。Chrome 的 V8 是 Engine，Engine 只负责翻译及运行代码，真正实现 JS 很多机制的是 Runtime，如 NodeJS
- 并发和并行是不同的，严格来讲并发不考虑是否能并行，并发只是一种调度策略
- I/O 密集型应用 CPU 其实很闲，所以 JS 采用事件驱动单线程，多线程之间要切上下文反而性能不好
- 用户态无法直接操作 CPU，所以直接开多个线程或进程让 OS 去完成。如 Chrome 的每个 Tab 是一个进程
- 在 NodeJS 中，Child Process 多用于执行一段命令行，它是 fork 了一段进程；Worker Threads 则不同，它是线程，例如 Web Worker 就是手动开线程，也因此能共享数据；最后是 Cluster 集群，处理的场景一般是 fork 多个进程，如 Web Server，所以像 PM2 就是做这个的
- Generator 做的其实是局部的细粒度控制任务，所以看起来像是用户态并发，其实还是同步的
- 异步 I/O 中，对这种「 简单且重复 」的劳动力工种，会开单独的线程去做，且是可以批量做的
- 关于 Event Loop 这个视频还不错 https://www.youtube.com/watch?v=8aGhZQkoFbQ
- 事件循环其实是 Engine 和 Runtime 合作的结果，Engine 提供了执行栈，Runtime 提供了异步接口
- 每个 Loop 中，JS 的主线程会先拿到「 所有 」的 MicroTask 执行，然后「 只会拿到一个 」TaskQueue 的任务执行，这样保证了异步任务永远先于下一个 Loop 被执行到
- CLI 等「 阻塞时间很短且可控 」的工具中可以用同步，另外对结果准确性要求很高的也最好用同步

# [如何用 Angular 实现深色模式](https://mp.weixin.qq.com/s/1tRWozobzzvTKjjbyyb0Kw)

看了下源码，值得学习的是持久化和 preloadingClass 的预加载
