- [企业文化与价值观](https://github.com/xufei/blog/issues/12)
    - 徐飞大大挺有意思的一篇新人鸡汤，摘抄了下来怕丢
- [飞书第一次发布会，尝试解答 B 端产品的几个难题](https://mp.weixin.qq.com/s/qbSgnXABuFa_bfvBRABC4Q)
    - 基于昨天读了飞书发布会，今天再读一篇，说几个细节
    - 很多东西加上时间维度的管理之后都会好用一个档次，比如将 Kanban 升级到 Roadmap
    - 双链其实很多文档管理器都有了，比如 Evernote，储存是单一链路的还是靠目录，但可以通过 Tag 来实现多对多关联，这对于知识群管理是非常有用的，在你的笔记数量达到一定程度时想要索引起来就会深有体会
    - 为什么说思维导图有时候比文本好使？因为它以最简单高效的方式呈现了关联性，而人看到关联就会映射出理解思路，这个比对文字重要得多
    - 在「 打通 」这件事上飞书确实做得好，比如会议记录会生成邮件抄送同时可以被会话和文档引用，这一个场景其实就打通了很多东西，没有打通就要多花费很多「 工具成本 」
    - 飞书说解决了「 空间 」和「 时间 」的「 错配 」，就拿会议室来说，这个确实是我们现在的痛点
- [再谈领域驱动设计](https://mp.weixin.qq.com/s/6mJGwth9i90Eu8MI6AjKxQ)
    - 业务逻辑是一系列状态的转换过程，而这些过程转换又被称为领域事件。领域事件使得领域模型的状态改变，从而提供业务能力。这就是问题域
    - 问题子域划分有点类似于递归，先解决小问题，但小也得成单元，是一个子域
    - 领域的限界很重要，否则无法自洽或导致溢出
    - 上下文表示域内一致的语言，就像讨论一个复杂的问题先要统一口径一样
    - DDD 强调用领域逻辑来驱动设计和开发工作，而不是通过数据库模型
    - 事件溯源就是只持久化领域事件，然后通过还原事件的方式将领域模型还原在最新的状态，这样可以将模型与数据库解耦
    - 问题子域对应了微服务，微服务之间的交互基于领域事件，通过订阅总线中「 感兴趣 」的事件来驱动整个模型
    - HATEOAS 的核心是领域模型通过 API 的方式向外提供能力，接口能力也是一种领域驱动的表现
- [How We Build a Design System](https://blog.bitsrc.io/how-we-build-our-design-system-15713a1f1833) —— Design System driven by Components
    - 设计语言保证了设计一致性，设计一致性是实现组件的基石，因为 UI-UX 的可复用单元是更细粒度的，描述起来可能要很多文字和配图
    - 组件是要被共享的，所以作者的团队选择了 Bit
        - Bit 基于 Base-UI 产生了 Evangelist，我理解为「 符合基础规范的定制化产物 」，还有模板、环境、流水线等机制保证组件产出过程中各个环节的尽可能一致
        - The design system’s team role is to facilitate and regulate, not block or enforce. 很赞成这句话
        - 作者认为这是很大的成功，因为可以独立开发但共享使用，大家可以减少各自的「 构造成本 」
        - 多平台框架无关也是个趋势。但..「 We’ve even been working with the Angular team itself to provide support for Bit with Angular. After taking everything into account, we believe React is the best solution for us at this point. 」😂
    - 友好的文档 —— 可索引、好触达，对于共享的组件是很重要的
    - 组件之间独立的版本控制会更好控制 —— 只在必要时升级，出问题时可以单独回滚或修复
    - 因为组件可以相互依赖和组合，版本依赖关系的发现也会变得很有用
        - 如一个基础组件升级后，在一个项目中的所有组件如何依赖了不同版本的这个组件，至少会有提醒。Bit 甚至有能力集成 Github，来提前「 预警 」它们
        - 这个概念作者称之为 Ripple，感觉点像依赖解析，因为 Bit 能「 掌控 」其平台上的所有组件，所以能去「 连接 」它们做强版本控制
        - 版本变更的通知有利于团队的沟通
    - 一个设计系统需要明确的职责划分
        - Designers usually talk about elements on their canvas.
        - Developers talk about the React component in their IDE.
        - Users will get the code, not the design.
        - 同时也需要良好的协作方式。作者提到了 Zeplin 与 Bit 的打通
    - 最后，为什么我们需要设计系统保证一致性？Helping users intuitively navigate, and successfully interact, with different parts of your applications without confusion. **This is your brand. You need a good brand.** 品牌提升影响力
- [How Facebook is bringing QUIC to billions](https://engineering.fb.com/2020/10/21/networking-traffic/how-facebook-is-bringing-quic-to-billions/)
    - 这里是 InfoQ 的翻译 https://www.infoq.cn/article/RQXyiLAFcL8KNfLckN2U
    - 介绍了一下 QUIC 和 HTTP3 的背景
        - 这里简单了解了下什么是 TCP 行头阻塞（ HOL ）https://qastack.cn/software/325881/is-it-a-good-idea-to-multiplex-blocking-streams-into-a-tcp-connection
        - QUIC 实质是将 TCP 迁移到 UDP，避免了 TCP 多路复用的尴尬，用 TSL 1.3 来实现可恢复，用 QLOG 实现可视化追踪
        - Node 15 已经尝试试验性支持 QUIC，见 https://mp.weixin.qq.com/s/8-82IaXIR6qEdHVgGBDG8A
        - 补充一篇介绍 https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit
    - Facebook 决定使用 QUIC 时，先用了大量内部流量来验证可行性，还搞了个负载均衡器来监测发布
        - 开发了一套叫 MVFST 的协议实现用于部署 QUIC，且得力于之前的 Proxygen、Zero、Fizz 可以平滑迁移（ 这东西没细讲 ）
    - 在对 Facebook 进行 QUIC 迁移时，尽管动态请求指标有所改善，但静态请求质量下降
        - 现象层原因是，只 enabled QUIC for dynamic GraphQL requests，导致 improving one type of request may have had detrimental side effects for others
        - 之前的 TCP 时代，先加载静态文本流然后视情况加载动态媒体流，可以通过阈值来控制，但对 QUIC 不起作用了，因为一瞬间尝试发送过多的请求，最终导致加载时间反而更长
    - 尝试规模化，并在静态请求中启用 QUIC
        - 静态数据流更容易消耗 CPU，也会对 congestion control (BBR) 阻塞控制的实现有影响
        - 先建立起监控以及上面提到的负载均衡器来调节
        - 一个有效的方法是 pace UDP packets，我理解是控制 UDP 包的大小，以实现 smoother data transmission
        - 另一个方向是 generic segmentation offload (GSO)，找了篇 https://doc.dpdk.org/guides/prog_guide/generic_segmentation_offload_lib.html 和 https://lwn.net/Articles/752956/ ，大致意思是说允许发送超额的片段数据，提高传输效率
    - 全员 QUIC 阶段
        - 上面提到了劣网环境 QUIC 有优势，所以在视频缓冲上验证了这个事实。提到了一个指标叫 Mean time between rebuffering (MTBR) 平均重缓存时间
        - Android 等移动设备上，会针对 TCP 行为评估下载带宽，而对 QUIC 会高估，最终反而造成卡顿
        - 另一个问题是 flow control 限流，这些之前适用于 TCP 的参数对 QUIC 不好用
    - 扩展到 Ins 及其它
        - 提到了 0-RTT，见 https://blog.cloudflare.com/introducing-0-rtt/
        - 随着 Chrome https://blog.chromium.org/2020/10/chrome-is-deploying-http3-and-ietf-quic.html 和 Apple https://developer.apple.com/videos/play/wwdc2020/10111/ 的支持，以及 IETF 会在 2021 提出对于 QUIC 的 RFC，作者相信更多公司会踏上这条路，并坚信 QUIC is essential to unlocking innovative internet applications
    - 总结，感觉是一篇科普性文章，提到了很多概念然后下一层去看一下是什么东西，整体上理解了 QUIC 的意图以及 Facebook 怎样一步步迁移到 QUIC 的，中间也提出了很多问题可能没有解决或者解决方案没有细说，但从作者提供的一部分数据来看 QUIC 确实是未来的一种不错的选择
- [架构师书单（ 上 ）](https://mp.weixin.qq.com/s/7ehggbjtIvEk002CUlNuBw)
    - 《 代码整洁之道 》✅
    - 《 重构 2.0 》✅
    - 《 改善代码质量的 101 个方法 》记得有本 JS 的好像
    - 《 架构师修炼之道——思维、方法与实践 》
    - 《 发布！设计与部署稳定的分布式系统 2.0 》
    - 《 持续交付 2.0 》✅

---

之后读后感无论是不是一句话都会用 Bullet List 来写，结构上清晰一些
