- [Web 应用的组件化（ 一 ）—— 基本思想](https://github.com/xufei/blog/issues/6)
    - 主要介绍了 Web 发展历程中组件化的演进
    - 组件化的目标：清晰的职责边界、松耦合
    - 组件化的手段：提高开发效率、减少部署成本
    - 组件化的几个方式：
        - B/C 的解耦，通过 API 层实现，分隔成独立的浏览器端应用
        - MV* 架构分层，视图和逻辑的解耦，发挥框架能力。如 Angular 中，双向绑定实现了 V 的渲染，多个 M 之间的交互通过 DI 实现，Directive 隔离了 DOM 及其行为逻辑
        - 利用 JS 的动态化，将变量或能异步加载的包独立出去（ DCS 和 MFE ），实现独立开发和部署，但尽量保持 SPA 的优势
- [Web 应用的组件化（ 二 ）—— 管控平台](https://github.com/xufei/blog/issues/7)
    - 组件化之后需要思考流程，怎么维护、怎么贡献 —— 怎么用
    - 组件库的依赖关系是项目名与版本号，这个是最常见的粒度，管理好依赖关系可以实现最小化发布
    - 组件要保证自洽安全，所以单测很重要
    - 组件文档强调可触达，很重要的一点就是可交互，无论是功能还是主题，所以建立个项目是必要的
    - 组件的生命周期中，交流、反馈必不可少，因此需要有个平台来承载
    - 组件化引入了工程复杂度，需要持续集成和部署的支持，包括发版、通知下游和更新文档，同时还需要做好权限安全
- [Web 应用组件化的权衡](https://github.com/xufei/blog/issues/22)
    - 组件化开发的优势：每一级都是易装配、可追踪、可管控的
        - 分治带来的是可管理性：组件化之后，整个应用成为了一个很清晰的树 —— 一眼就能看清包含关系，也能够很容易理清数据的传递方向。整个应用可以从叶子节点，逐步向上测试，哪一级出了问题，可以很容易发现
    - 在 Angular 中，Template 其实是耗材因为几乎没法复用，而其它组件化就是资产。对于资产要长远、持续、优雅、细致、详尽
    - 业务数据层（ 我理解包括 VO、API、基本逻辑的 Util、Service ）从长远来看会是一个没有框架差异的东西
        - 如我们都用 TS 写，且没有 Angular Service（ DI ）支持，这样同一业务线中的多条产品线都可以复用这里的基础组件
    - 组件化的粒度权衡有几个考虑点
        - 业务架构，需要理解业务体系
        - 个人赞同组件之间尽可能避免继承，除非对于外界是一个非常紧密的单元
        - 对于接口设计，把组件实现为一种插件平台；针对组件的各种形态，将其特征分离出来当成一种插件。结合上一点，就是插件配置
        - 样式类同样可以充当接口，这样便于实现主题定制，虽然这与 Scoped CSS 相悖
- [组件化 or 分层](https://github.com/xufei/blog/issues/50)
    - 真正的视图仍然是分层的
        - 是函数式、流、OOP，那都是各框架自身所倾向的方法论，并不影响把视图隔离出去这么一个明显“分层”的动作
    - 作者倡导的方法论
        - 细粒度作为黑盒组件
        - 逻辑分层、集中管理
        - 大面积的页面视图模板化
    - 翻译一下就是
        - 通过组件引入机制，引入细粒度的基础组件 —— 组件库
        - 开放受管控的代码编写机制，编写我们的逻辑层 —— 工程架构规范
        - 可视化或者通过模板编写大粒度视图，甚至页面 —— 模板物料库
- [单页应用的数据流方案探索](https://github.com/xufei/blog/issues/47)
- [Let's stop fooling ourselves. What we call CI/CD is actually only CI](https://dev.to/canarian/let-s-stop-fooling-ourselves-what-we-call-ci-cd-is-actually-only-ci-13c)
