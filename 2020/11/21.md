# [Web 应用的组件化（ 一 ）](https://github.com/xufei/blog/issues/6)

## 概要

主要介绍了 Web 发展历程中组件化的演进

## 笔记

- 开发团队的优化途径：减少部署成本、提高开发效率
  - 减少部署成本，比如迁移到开源的、产品化的集群
  - 提高开发效率，比如尽可能复用内部成果
- 《 文明 》里有一项科技成果叫 Replacement Parts，其实就是工程上的组件
  - 组件建造完成后，通常会引入规则引擎来支持可配置，从而以最小的成本来组织起大量的组件，串联成业务流程
- 以在线工具为例，这样的应用在 Web 1.0 时代是行不通的，Web 2.0 其实是将 C/S 迁移到 B/S，形成了天然的隔离
  - 前端的业务重了，不代表不需要展示和逻辑分层了。其实视图代码天然可以做到这一点，如 HTML/CSS 和异步加载的 JS
  - 前端的逻辑以静态文件的方式存放在高性能服务器上，如 CDN（ Content Delivery Network ）
- SPA 的优势用户体验好和运行高效。交互不再重依赖服务，类似 iframe 的嵌套不再需要冗余的文件传输和内存管理
  - 但 SPA 带来了工程复杂度的提升，所以引来了前端架构的升级改造
- 设计模式中 MVC 的 V 其实是服务端渲染，即生成或映射 HTML，但在 SPA 中 V 已经是客户端渲染了，这才形成了独立的浏览器端（ 客户端的一种 ）
  - 以 Angular 为例，双向绑定实现了 V 的渲染，多个 M 之间的交互通过 DI 实现。牺牲的是一点性能和调试成本，但迎来了松耦合和可复用性
- 前端的 HTML/CSS 其实是一种配置化语言，对标服务端的 XML 就很好理解
  - 与服务端不同的是，前端逻辑以 JS 的方式将入口放在了配置（ HTML 标签 ）中才能运行
  - JS 启动之后就是框架的舞台了：Bootstrap、Require、Template Parser、Scope、Route、Binding、Injection 等等
- 组件化的终极目的是：清晰的职责边界和松耦合，便于单测和复用
  - HTML 的配置单元是 DOM，HTML 的组件化就是 Template 模板，也成为界面或视图的片段化
  - CSS 的组件化催生了 LESS、SASS，可以使用变量和函数
  - JS 的组件化单位是功能单元。先复用，然后通过动态化消灭全局变量
  - JS 与 DOM 之间的绑定关系也需要松耦合，如 Angular 的 Directive 就是解耦了 DOM 行为的逻辑

## 总结

- 组件化的目标：清晰的职责边界、松耦合
- 组件化的手段：提高开发效率、减少部署成本
- 组件化的几个方式：
  - B/C 的解耦，通过 API 层实现，分隔成独立的浏览器端应用
  - MV* 架构分层，视图和逻辑的解耦，发挥框架能力。如 Angular 中，双向绑定实现了 V 的渲染，多个 M 之间的交互通过 DI 实现，Directive 隔离了 DOM 及其行为逻辑
  - 利用 JS 的动态化，将变量或能异步加载的包独立出去，实现独立开发和部署，但尽量保持 SPA 的优势

# [Web 应用的组件化（ 二 ）](https://github.com/xufei/blog/issues/7)

## 概要

在组件化的基础上，如何有效地管理组件

## 笔记

- HTML 片段管控
  - 意义是什么？保证一致性、专业性
  - HTML 的索引和同步有个天然的障碍，就是必须处于同一空间
  - 拆分仓库的结果就是要管控依赖关系，有点像组件库了但是粒度更小
  - 管理的方式无外乎手动配置和代码分析
- JS 模块管控
  - JS 承载逻辑，所以逻辑的实现和依赖关系要分离管理。比较理想的情况是依赖关系全部用配置搞定，
  - 分离也是有层次的，因为管理粒度和使用粒度不一致，例如一个组件是一个 Class 但一套组件库是一个 NPM 包
- 单元测试：必须以代码分层支持为前提。如 Angular 中视图类能操作 DOM
- 文档：实时可见可编辑的形式更友好，可触达性高才能发挥文档之于代码的优势
- 示例：纯文字和可交互示例，显然对于前端带有视图的组件来说后者更好。这也是为什么组件库文档通常都需要单独开发的原因
- 项目目录管理：提到了一段挺有意思的东西
  - 「 fork 的项目默认未必要有实体文件，只有当产生了修改或者新增操作的时候才创建，剩下的还引用原来的就可以了。我们这里的项目复制功能是为项目化版本而考虑的，经常出现一个产品版本支持多个客户项目的情况，所以可能会用得着这个特性 」
- 评论：需要给用户交流平台、给开发者收集意见和建议的渠道
- 权限：因为整个流程复杂多变，所以需要对权限分层管理
- 国际化：多语言从某个角度讲也是组件化，要保证功能一致（ 表达的意思 ）但表现形式不同（ 语言只是字符 ）
- 静态资源：需要独立于产品化项目发布
- 主题：组件化可以实现 Component Level 的 CSS 接口，使得功能和样式是解耦的，从而实现多套主题与组件库匹配可用
- 发布：最小化、高效、友好、安全的发布
  - 作者提到一个合作原则：「 解决问题的过程中，如果引入了新的问题，要求负责解决原问题的人也一起解决掉 」
  - 这里有一个提示：持续集成应该是可配的
- 可用：系统化之后要可视化，强调命令行的升级

## 总结

- 组件化之后需要思考流程，怎么维护、怎么贡献 —— 怎么用
- 组件库的依赖关系是项目名与版本号，这个是最常见的粒度，管理好依赖关系可以实现最小化发布
- 组件要保证自洽安全，所以单测很重要
- 组件文档强调可触达，很重要的一点就是可交互，无论是功能还是主题，所以建立个项目是必要的
- 组件的生命周期中，交流、反馈必不可少，因此需要有个平台来承载
- 组件化引入了工程复杂度，需要持续集成和部署的支持，包括发版、通知下游和更新文档，同时还需要做好权限安全

# [Web 应用组件化的权衡](https://github.com/xufei/blog/issues/22)

## 笔记

- 组件化开发的优势：每一级都是易装配、可追踪、可管控的
  - 分治带来的是可管理性：组件化之后，整个应用成为了一个很清晰的树 —— 一眼就能看清包含关系，也能够很容易理清数据的传递方向。整个应用可以从叶子节点，逐步向上测试，哪一级出了问题，可以很容易发现
- 「 一个软件产品中，如果把核心稳定的部分视为资产，灵活可变的部分视为耗材，我们如何对待资产 ？如何对待耗材 ？」这是个有趣的命题
  - 「 对待资产，我们一般会比较重视，会有长远的规划，优雅的实现，持续的维护，细致的测试，详尽的文档等等，但是对于耗材，基本上会视为一次性的东西，不会有这么严谨的过程 」
  - 组件明显属于资产，而模板一般属于耗材
- 是否适合组件化的几个成本：实现难度、集成难度
- 「 从长远来看，业务数据层会是一个基本没有框架差异的东西 」
  - 具体到视图层才有差异，加上视图才产生的前端应用，才引入的框架问题
- 「 组件树的层级不宜过深，从根节点算起，应当尽可能控制在 3 到 5 层内 」
- 数据通讯方式并不唯一。这里引出来一个概念是「 业务架构 」，也就是具体的实现方式要看场景
- 前端的数据层很关键，如需要关注数据同步、是否有请求的浪费。WebSocket 和 GraphQL 都是一种很重要的尝试
- 如何看待「 可视化继承 」？作者认为用处很少，相反可以换种思路 —— 「 保持组件不变，通过不同的配置项使其相应不同的功能 」
- 「 怎样让我们的组件既强大，又便于使用 ？」—— 「 把组件实现为一种插件平台；针对组件的各种形态，将其特征分离出来当成一种插件 」
- 「 再回头看 Web Components 」这一节讲的很好..
  - 作者认为 Web Components 很尴尬，因为例如 Shadow DOM 也可以同样做到逻辑隔离的效果
  - 共性都是将一个标签作为入口，运行时往其中放入具体实现细节
  - Scoped CSS 则代表着样式内联化，想提高独立性，但奈何 `/deep/` 和 `::shadow` 打破了规矩

## 总结

- 组件化开发的优势：每一级都是易装配、可追踪、可管控的
  - 分治带来的是可管理性：组件化之后，整个应用成为了一个很清晰的树 —— 一眼就能看清包含关系，也能够很容易理清数据的传递方向。整个应用可以从叶子节点，逐步向上测试，哪一级出了问题，可以很容易发现
- 在 Angular 中，Template 其实是耗材因为几乎没法复用，而其它组件化就是资产。对于资产要长远、持续、优雅、细致、详尽
- 业务数据层（ 我理解包括 VO、API、基本逻辑的 Util、Service ）从长远来看会是一个没有框架差异的东西
  - 如我们都用 TS 写，且没有 Angular Service（ DI ）支持，这样同一业务线中的多条产品线都可以复用这里的基础组件
- 组件化的粒度权衡有几个考虑点
  - 业务架构，需要理解业务体系
  - 个人赞同组件之间尽可能避免继承，除非对于外界是一个非常紧密的单元
  - 对于接口设计，把组件实现为一种插件平台；针对组件的各种形态，将其特征分离出来当成一种插件。结合上一点，就是插件配置
  - 样式类同样可以充当接口，这样便于实现主题定制，虽然这与 Scoped CSS 相悖

# [组件化 or 分层](https://github.com/xufei/blog/issues/50)

- 真正的视图仍然是分层的，分出来的那个展示部分都可以泛指为模板
- 至于分层到什么形态，是函数式、流、OOP，那都是各框架自身所倾向的方法论，并不影响把视图隔离出去这么一个明显“分层”的动作
- 视图不过是逻辑容器的附属物，可以视为是一种配置而已
- 作者倡导的方法论
  - 细粒度作为黑盒组件
  - 逻辑分层、集中管理
  - 大面积的页面视图模板化
- 翻译一下就是
  - 通过组件引入机制，引入细粒度的基础组件 —— 组件库
  - 开放受管控的代码编写机制，编写我们的逻辑层 —— 工程架构规范
  - 可视化或者通过模板编写大粒度视图，甚至页面 —— 模板物料库
