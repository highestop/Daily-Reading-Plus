# [Webpack 5 Module Federation: A game-changer in JavaScript architecture](https://medium.com/swlh/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669)

> 翻译：[Webpack 5 Module Federation: JavaScript 架构的变革者](https://zhuanlan.zhihu.com/p/120462530)
>
> 延伸：[Youtube > Introducing Federated Modules in Webpack 5](https://www.youtube.com/watch?v=D3XYAx30CNc)

- 术语：
  - federation 指在 browser 或 node 环境，在一个 JS 运行时动态加载其它 JS，不受 build 和 bundlize 的影响
  - host 为最先被 init 的 webpack 构建对象
  - remote 为被消费的 webpack 对象
  - bidirectional 理解为双向运行时构建支持
    - 一个 bundle 既可以作为一个 host 也可以作为一个 remote，均发生在运行时，但在一个运行时的角色只能有一种
- 理解运行时的双向支持？
  - host 的依赖（ 如各种 vendors ）会被 remote 共享，remote 也支持降级只使用私有依赖（ 减少边界影响 ）
  - remote 独有的依赖也会被 Webpack 运行时从其构建源中下载
  - 从 A 切到 B，host 是 A remote 是 B。此时刷新页面，host 是 B，切到 A 后，remote 是 A
- 理解 federation 的编排
  - 通过定义 ModuelFederationPlugin 来使用联邦机制
  - 通过 name 定义组件名称
  - 通过 remotes 定义会消费谁
  - 通过 exposes 定义会被共享的模块
  - 通过 shared 定义可以被共享的依赖（ 不共享的会被降级为私有依赖 ）
  - 那么 library 是做什么的？
    - 在 SSR 案例中可见，type 被设为了 commonjs-module，而上面的则是 var
    - 需要额外成本实现 federated SSR
- 展示效果
  - 无论 host 还是 remote 都不会在编译时留下冗余的代码
    - federation 的 config 会额外初始化 entry，但 federation 的 entry 不是一般的 entry 只有几 KB
  - next 之后会支持 Webpack 5

# [精读《 Webpack 5 新特性 - 模块联邦 》](https://zhuanlan.zhihu.com/p/115403616)

- 针对共享模块，之前的思路是：
  - NPM 共享，可能是 monorepo 便于管理维护依赖关系
  - UMD 共享，利用 Webpack UMD 格式的通用性，如 SystemJS
  - 微前端模式，更像是高阶的组合构建。多个子应用独立解决了耦合问题但共享问题还需要用前两者来解决
- 联邦模式：
  - 去中心化
  - 更小粒度的共享
- 问题：多个模块单独部署发布，如何将 remotes 与 exposes 通过 name 做告知的？
  - 在 A 中用 scripts 的方式声明远程 JS 模块地址（ Angular、React 中的 Lazy ）
  - 在 A 的 Webpack 中声明 remote
  - 在 A 的代码中定义 remote name 的 ref 从而完成加载
